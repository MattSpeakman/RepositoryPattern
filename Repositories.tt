<#@ template language="C#" debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="Microsoft.CSharp" #>
<#@ import namespace="System.Text" #>
<#
	// this is the relative path of the project from the solution folder.  We're reading the C# source code to get our type names.
	// So you need to point this T4 Template at the class generated by an EDMX file, which represents the database context.
	//string sourceFile = Host.ResolveAssemblyReference("$(SolutionDir)") + @"T4TemplateSandbox\Models\CallLogging.Context.cs";

	string sourceFile = this.Host.ResolvePath("FILENAME.Context.cs"); // relative path.
	string rootNamespace = "ROOTNAMESPACE";

	string[] RepositoryTypeNames = GetTypesFromCSharpSourceFile(sourceFile);
	string[] RepositoryTypePropertyNames = GetTypesNamesFromCSharpSourceFile(sourceFile);
	string sourceContextName = GetContextNameFromFile(sourceFile).Trim();

#>// *************************************
// AUTO GENERATED CODE (C) Matt Speakman (2016)
// *************************************

using <#= rootNamespace #>.Interfaces;
using <#= rootNamespace #>.Models;
using System.Data.Entity;

namespace <#= rootNamespace #>.Interfaces
{
	public partial interface I<#= sourceContextName #>
    {
<# foreach (string className in RepositoryTypeNames) { #>
		DbSet<<#= className #>> <#= GetSubstitutePropertyName(className, RepositoryTypeNames, RepositoryTypePropertyNames) #> { get; set; }
<# } #>
    }

<# foreach (string className in RepositoryTypeNames) { #>
	public partial interface I<#= GetSubstituteName(className) #>Repository : IRepository<<#= className #>>
    {
        // <#= className #> FindByID(int <#= className #>ID);
    }		
<# } #>

}
namespace <#= rootNamespace #>.Models
{
	[AutoRegister(Behaviour = AutoRegisterBehaviour.RegisterTypeOnly)]
	public partial class <#= sourceContextName #> : I<#= sourceContextName #>
    {        
    }    
}
namespace <#= rootNamespace #>.Classes
{
<# foreach (string className in RepositoryTypeNames) { #>	
	public partial class <#= GetSubstituteName(className) #>Repository : RepositoryBase<<#= className #>>, I<#= GetSubstituteName(className) #>Repository
    {
        public <#= GetSubstituteName(className) #>Repository(I<#= sourceContextName #> context) : base(context as DbContext)
        {
        }

        // <#= className #> I<#= className #>Repository.FindByID(int <#= className #>ID)
        // {
		// 	return this.GetAll().FirstOrDefault(x=> x.<#= className #>ID == <#= className #>ID);
        // }
    }	
<# } #>
}
<#+ 
	//    public virtual DbSet<PolicyImport> PolicyImports { get; set; }
	string[] GetTypesFromCSharpSourceFile(string fileName)
	{
		using (var sr = new StreamReader(fileName))
        {
			string fileText = sr.ReadToEnd();

			var reg = new Regex(@"(?<=DbSet<)(.*)(?=>)");
            var matches = reg.Matches(fileText);

            return matches.Cast<Match>().Select(s=> s.Value).ToArray();
        }
	}

	string[] GetTypesNamesFromCSharpSourceFile(string fileName)
    {
		using (var sr = new StreamReader(fileName))
        {
			string fileText = sr.ReadToEnd();

			var reg = new Regex(@"(?<=>\s)(.*)(?=\s{)");
			//var reg = new Regex(@"(?<=DbSet<)(.*)(?=>)(.*)(?={");
            var matches = reg.Matches(fileText);

            return matches.Cast<Match>().Select(s=> s.Value).ToArray();
        }
    }

	string GetContextNameFromFile(string fileName)
    {
        using (var sr = new StreamReader(fileName))
        {
            string fileText = sr.ReadToEnd();
            var reg = new Regex(@"(?<=class )(.*)(?=:)");
            var matches = reg.Matches(fileText);

            return matches.Cast<Match>().First().Value;
        }
    }

	string GetSubstituteName(string uglyName)
    {
		// is it really an ugly name?
		if(uglyName.ToUpper() != uglyName) return uglyName;

		// CUSTOMER_CLIENT_ADDRESS
		var chars = uglyName.ToLower().ToCharArray();
		var sb = new StringBuilder();
		chars[0] = char.ToUpper(chars[0]);
		bool nextIsCaps = false;
		foreach(char ch in chars)
        {
			if(ch == '_')
			{
				 nextIsCaps = true;
            }
			else
            {
				if(nextIsCaps)
				{         
					sb.Append(char.ToUpper(ch));
					nextIsCaps = false;            
				}
				else            
					sb.Append(ch);            
            }
        }
		return sb.ToString();

		//return uglyName;
    }

	string GetSubstitutePropertyName(string propertyName, string[] origs, string[] replaces)
    {
		int idx = -1;
		for(int i=0; i<origs.Length; i++)
        {
			if(origs[i] == propertyName){
				 idx = i;
				break;
            }
        }
		if(idx == -1) return propertyName;

		return replaces[idx];
    }
#>
